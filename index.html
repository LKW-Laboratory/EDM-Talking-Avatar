<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Talking Character â€“ EDM</title>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.js"></script>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#000; overflow:hidden; }
    canvas { width:100%; height:100%; display:block; }
    #audioButton {
      position: absolute; top: 16px; left: 16px; z-index: 10;
      padding: 10px 16px; border: none; border-radius: 10px;
      background: #fff; color:#111; font-weight:600; cursor:pointer;
      box-shadow: 0 6px 18px rgba(0,0,0,.25);
    }
    #hint { position:absolute; bottom:16px; left:16px; color:#bbb; font-family:system-ui, sans-serif; font-size:12px }
  </style>
</head>
<body>
  <button id="audioButton">ðŸ”Š Play Audio</button>
  <div id="hint">drag = orbit Â· wheel = zoom</div>
  <canvas id="renderCanvas"></canvas>
  <!-- Use the exact filenames you provided -->
  <audio id="voice" src="EDM Dailouge.mp3" preload="auto"></audio>

  <script>
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true, doNotHandleContextLost: true });
    let scene, lipSyncGroups = [];

    const createScene = async () => {
      scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color4(0,0,0,1);

      const camera = new BABYLON.ArcRotateCamera("camera", Math.PI/2, Math.PI/2.2, 2.2, new BABYLON.Vector3(0, 1, 0), scene);
      camera.lowerRadiusLimit = 1.2;
      camera.upperRadiusLimit = 4.0;
      camera.wheelPrecision = 80;
      camera.attachControl(canvas, true);

      const light = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
      light.intensity = 1.25;

      // Optional: soft ground shadow (disabled by default)
      // const ground = BABYLON.MeshBuilder.CreateGround("g", {width:10, height:10}, scene);
      // ground.receiveShadows = true;

      const result = await BABYLON.SceneLoader.ImportMeshAsync("", "./", "EDM Avatar.glb", scene);
      const root = result.meshes[0];

      // Reset quaternions -> Euler and face forward
      result.meshes.forEach(m => { if (m.rotationQuaternion) m.rotationQuaternion = null; });
      root.rotation = new BABYLON.Vector3(0, Math.PI, 0);

      // Collect likely lip-sync animation groups
      const keywords = ["wolf3d", "viseme", "lipsync", "lip", "phoneme"];
      lipSyncGroups = scene.animationGroups.filter(g => {
        const n = g.name.toLowerCase();
        return keywords.some(k => n.includes(k));
      });

      // Fallback: if nothing matched, play all anim groups for talking
      if (lipSyncGroups.length === 0 && scene.animationGroups.length > 0) {
        lipSyncGroups = scene.animationGroups.slice();
      }

      // Ensure groups are paused initially
      lipSyncGroups.forEach(g => g.stop());

      return scene;
    };

    createScene().then(() => {
      engine.runRenderLoop(() => { if (scene) scene.render(); });
    });

    window.addEventListener("resize", () => engine.resize());

    // Audio controls
    const audio = document.getElementById("voice");
    const button = document.getElementById("audioButton");

    const playLipSync = () => {
      lipSyncGroups.forEach(g => {
        try { g.stop(); } catch(e) {}
        // Play once, from start
        g.start(false, 1.0, g.from, g.to, false);
      });
    };

    button.addEventListener("click", async () => {
      // On iOS/Safari, start the audio in a user gesture
      try {
        if (audio.paused) {
          audio.currentTime = 0;
          await audio.play();
        } else {
          audio.pause();
          audio.currentTime = 0;
          await audio.play();
        }
      } catch(e) {
        console.warn("Audio play blocked:", e);
      }
      playLipSync();
    });

    audio.addEventListener("ended", () => {
      lipSyncGroups.forEach(g => g.stop());
    });
  </script>
</body>
</html>
